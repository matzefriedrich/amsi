namespace Windows.Security.AntiMalwareScan.Interop
{
    using System;
    using System.Linq.Expressions;
    using System.Reflection;
    using System.Runtime.InteropServices;

    internal static class Kernel32
    {
        [DllImport("kernel32.dll", EntryPoint = "LoadLibrary", CharSet = CharSet.Unicode)]
        public static extern IntPtr LoadLibrary(
            [MarshalAs(UnmanagedType.LPTStr)] string lpFileName);

        [DllImport("kernel32.dll", EntryPoint = "FreeLibrary")]
        public static extern int FreeLibrary(
            IntPtr hModule);

        [DllImport("kernel32.dll", EntryPoint = "GetProcAddress", CharSet = CharSet.Unicode, SetLastError = true)]
        public static extern int GetProcAddress(
            IntPtr hModule,
            [MarshalAs(UnmanagedType.LPStr)] string lpProcName);

        [DllImport("kernel32.dll", EntryPoint = "GetLastError")]
        public static extern uint GetLastError();

        internal static bool IsDefined<TResult>(this Expression<Func<TResult>> expression)
        {
            ArgumentNullException.ThrowIfNull(expression);

            if (expression.Body is not MethodCallExpression call) return false;

            var importAttribute = call.Method.GetCustomAttribute<DllImportAttribute>();
            string lpFileName = importAttribute?.Value;
            IntPtr hModule = LoadLibrary(lpFileName);

            if (hModule == IntPtr.Zero) return false;

            try
            {
                int procAddress = GetProcAddress(hModule, call.Method.Name);
                uint hr = GetLastError();
                return hr switch
                {
                    SystemErrorCodes.ERROR_PROC_NOT_FOUND => false,
                    _ => procAddress != 0
                };
            }
            finally
            {
                FreeLibrary(hModule);
            }
        }
    }
}